/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/game/aiPlayer.js":
/*!******************************!*\
  !*** ./src/game/aiPlayer.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Board = __webpack_require__(/*! ./board.js */ \"./src/game/board.js\");\nclass AIPlayer{\n    constructor(mark = 'X', maxDepth = -1){\n        this.mark = mark;\n        this.maxDepth = maxDepth;\n        this.nodesMap = new Map();\n    }\n    opponentMark(){\n        return this.mark === 'X' ? 'O' : 'X';\n    }\n    getBestMove(board, max = true, depth = 0){\n        if(depth == 0){\n            this.nodesMap.clear();\n        }\n        if(board.gameOver() || depth === this.maxDepth ) {\n            if(board.winner() === this.mark) {\n                return 100 - depth;\n            } else if (board.winner() === this.opponentMark()) {\n                return -100 + depth;\n            }\n            return 0;\n        }\n        //MAX/MIN\n        //Initialize best to the lowest possible value if max, highest if min\n            let best = max === true ? -100 : 100;\n            //Loop through all empty cells\n            board.validPositions().forEach(pos => {\n                //Initialize a new board with a copy of our current state\n                const child = new Board();\n                child.grid = [];\n                board.grid.forEach( (row) => { child.grid.push([...row]) });\n\n                let mark = max === true ? this.mark : this.opponentMark();\n                //Create a child node by inserting the maximizing symbol x into the current empty cell\n                child.placeMark(pos, mark);\n\n                //Recursively calling getBestMove this time with the new board and minimizing turn and incrementing the depth\n                const nodeValue = this.getBestMove(child, (!max), depth + 1);\n                //Updating best value\n                best = max === true ? Math.max(best, nodeValue): Math.min(best, nodeValue);\n                //If it's the main function call, not a recursive one, map each heuristic value with it's moves indices\n                if (depth == 0) {\n                    //Comma separated indices if multiple moves have the same heuristic value\n                    //let movesArr = [];\n                    const moves = this.nodesMap.has(nodeValue)\n                        ? this.nodesMap.get(nodeValue) + \"-\" + (pos)\n                        : pos;\n                    this.nodesMap.set(nodeValue, moves);\n                }\n            });\n            //If it's the main call, return the index of the best move or a random index if multiple indices have the same value\n            if (depth == 0) {\n                let returnValue;\n\n                if (typeof this.nodesMap.get(best) == \"string\") {\n                    let arr = this.nodesMap.get(best).split(\"-\");\n                    let numArr = [];\n                    for(let i =0; i < arr.length; i++){\n                        numArr.push([parseInt(arr[i][0]), parseInt(arr[i][2])]);\n                    }\n                    //console.log(numArr);\n                    const rand = Math.floor(Math.random() * numArr.length);\n                    returnValue = numArr[rand];\n                } else {\n                    returnValue = this.nodesMap.get(best);\n                }\n                //run a callback after calculation and return the index\n                return returnValue;\n            }\n            //If recursive return best scored move\n            return best;\n    }\n}\n\n\n\nmodule.exports = AIPlayer;\n\n\n//# sourceURL=webpack:///./src/game/aiPlayer.js?");

/***/ }),

/***/ "./src/game/board.js":
/*!***************************!*\
  !*** ./src/game/board.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const MoveError = __webpack_require__(/*! ./moveError */ \"./src/game/moveError.js\");\n\nclass Board{\n    constructor(){\n        this.grid = Board.makeGrid();\n    }\n\n    static makeGrid(){\n        const grid = [];\n        for(let i = 0; i < 3; i++){\n            grid.push([]);\n            for(let j = 0; j < 3; j++){\n                grid[i].push(null);\n            }\n        }\n        return grid;\n    }\n\n    won(mark){\n        let three_adjacent =[\n        [this.grid[0][0], this.grid[1][1], this.grid[2][2]], //diagonals\n        [this.grid[0][2], this.grid[1][1], this.grid[2][0]],\n\n        [this.grid[0][0], this.grid[0][1], this.grid[0][2]], //horizontals\n        [this.grid[1][0], this.grid[1][1], this.grid[1][2]],\n        [this.grid[2][0], this.grid[2][1], this.grid[2][2]],\n\n        [this.grid[0][0], this.grid[1][0], this.grid[2][0]], //verticals\n        [this.grid[0][1], this.grid[1][1], this.grid[2][1]],\n        [this.grid[0][2], this.grid[1][2], this.grid[2][2]]\n        ]\n        for(let configs = 0; configs < three_adjacent.length; configs++){\n            let count = 0;\n            three_adjacent[configs].forEach(el=>{\n                if(el === mark){\n                    count+=1;\n                }\n            });\n            if(count === 3){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //returns array of winning positions\n    winningPositions(mark){\n        let three_adjacent =[\n        [[0,0], [1,1], [2,2]], //diagonals\n        [[0,2], [1,1], [2,0]],\n\n        [[0,0], [0,1], [0,2]], //horizontals\n        [[1,0], [1,1], [1,2]],\n        [[2,0], [2,1], [2,2]],\n\n        [[0,0], [1,0], [2,0]], //verticals\n        [[0,1], [1,1], [2,1]],\n        [[0,2], [1,2], [2,2]]\n        ]\n        let winningPositions = []\n        for(let group = 0; group < three_adjacent.length; group++){\n            winningPositions = [];\n            three_adjacent[group].forEach(pos=>{\n                if(this.getMark(pos) === mark){\n                    winningPositions.push(pos);\n                }\n            });\n            if(winningPositions.length === 3){\n                return winningPositions;\n            }\n        }\n        return [];\n    }\n\n    gameOver(){\n        let validPositions = this.validPositions();\n        if(this.won('X') || this.won('O') || (validPositions.length === 0)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\n    winner(){\n        if(this.won('X')){\n            return 'X';\n        }\n        else if(this.won('O')){\n            return 'O';\n        }\n        else{\n            return null;\n        }\n    }\n\n    isValid(pos){\n        if((pos.length !== 2)){\n            console.log(\"invalid length\");\n            return false;\n        }\n        if(typeof(pos[0]) !== 'number' || typeof(pos[1]) !== 'number'){\n            return false;\n        }\n        if(pos[0] < 0 || pos[0] > 2){\n            return false;\n        }\n        else if(pos[1] < 0 || pos[1] > 2){\n            return false;\n        }\n        else{\n            return true;\n        }\n    }\n\n    getMark(pos){\n        if(this.isValid(pos)){\n            return this.grid[pos[0]][pos[1]];\n        }\n        else{\n            //console.log(\"Invalid position -- not valid entry/ not on the board!\");\n            throw new MoveError(`${pos} is not valid position on the board`);\n        }\n    }\n\n    isEmpty(pos){\n        return (this.getMark(pos) === null);\n    }\n\n    validPositions(){\n        let positions = [];\n        for(let i =0; i < 3; i ++){\n            for(let j =0; j < 3; j ++){\n                if(this.isEmpty([i,j])){\n                    positions.push([i,j]);\n                }\n            }\n        }\n        return positions;\n    }\n\n    placeMark(pos, mark){\n        if(this.isEmpty(pos)){\n            this.grid[pos[0]][pos[1]] = mark;\n        }\n        else{\n            throw new MoveError(`${pos} is not an empty position on the board`);\n        }\n    }\n\n    print(){\n        console.log(\"    0  1  2\");\n        for(let row = 0; row < 3; row++){\n            let rowStr = \"\";\n            rowStr += row + \"  \";\n            for(let col = 0; col < 3; col++){\n                if(this.grid[row][col] === null){\n                    rowStr += \" _ \";\n                }\n                else{\n                    rowStr += ` ${this.grid[row][col]} `;\n                }\n            }\n            console.log(rowStr);\n        }\n    }\n}\nBoard.marks = ['X', 'O'];\nmodule.exports = Board;\n\n//let b = new Board();\n//b.print();\n\n//# sourceURL=webpack:///./src/game/board.js?");

/***/ }),

/***/ "./src/game/game.js":
/*!**************************!*\
  !*** ./src/game/game.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Board = __webpack_require__(/*! ./board.js */ \"./src/game/board.js\");\nconst MoveError = __webpack_require__(/*! ./moveError */ \"./src/game/moveError.js\");\nconst InputError = __webpack_require__(/*! ./inputError */ \"./src/game/inputError.js\");\nconst AIPlayer = __webpack_require__(/*! ./aiPlayer.js */ \"./src/game/aiPlayer.js\");\n\nclass Game{\n    constructor(ai = false, aiMark ='X', aiLevel = -1){\n        this.board = new Board();\n        this.ai = ai;\n        if(ai === true){\n            this.aiMark = aiMark;\n            this.aiPlayer = new AIPlayer(aiMark, aiLevel);\n        }\n        this.currPlayerMark = Board.marks[0];\n    }\n\n    isOver(){\n        return this.board.gameOver();\n    }\n\n    winningPositions(mark){\n        if (this.winner() !== null){\n            return this.board.winningPositions(mark);\n        }\n    }\n\n    winner(){\n        return this.board.winner();\n    }\n    makeMove(pos){\n        this.board.placeMark(pos, this.currPlayerMark);\n        this.swapTurn();\n    }\n    swapTurn(){\n        this.currPlayerMark = this.currPlayerMark === Board.marks[0] ?  Board.marks[1] : Board.marks[0];\n    }\n\n    validInput(input){\n        try{\n            if(typeof(parseInt(input)) !== 'number' || isNaN(parseInt(input)) ){\n            throw new InputError(`${input} is not a valid input. Please enter a number (0 <= n <=2).\\n`);\n            }\n        } catch(e){\n            if(e instanceof InputError){\n                console.log(e.message);\n            }\n            else{\n                throw(e);\n            }\n        }\n    }\n\n    run(reader, completionCallback){\n        this.getMove(reader, (pos) => {\n            try{\n                this.makeMove(pos);\n            } catch(e){\n                if(e instanceof MoveError){\n                    console.log(e.message);\n                }\n                else if(e instanceof InputError){\n                    console.log(e.message);\n                }\n                else{\n                    console.log(e.message);\n                    throw e;\n                }\n            }\n            if(this.isOver()){\n                this.board.print();\n                let winner = this.board.winner();\n                console.log(\"\\nGame Over!\");\n                if(winner === null){\n                    console.log('TIE -- NO ONE WINS!\\n');\n                }\n                else{\n                    console.log(`${winner} Wins!\\n`);\n                }\n                completionCallback();\n            }\n            else {\n                this.run(reader, completionCallback);\n            }\n        });\n    }\n    validPositionInput(input){\n        if(!(Number.isNaN(input[0]) || Number.isNaN(input[1]))){\n            return true;\n        }\n    }\n\n    getMove(reader, callback){\n        let aiMove = false;\n        let aiPos = [];\n        if(this.ai === true && this.aiMark === this.currPlayerMark){\n            aiMove = true;\n            aiPos = this.aiPlayer.getBestMove(this.board);\n        }\n        else{\n            this.board.print();\n        }\n        console.log(`\\n${this.currPlayerMark}'s Turn`);\n\n        if(aiMove === false){\n            console.log(\"\\nWhere would you like to move? \\t\");\n            reader.question(\"\\Please enter row number (0 <= n <= 2): \\t\", (row_input)=>{\n                let row = parseInt(row_input);\n                this.validInput(row_input);\n                reader.question(\"\\Please enter column number (0 <= n <= 2): \\t\", (col_input)=>{\n                    this.validInput(col_input);\n                    let col = parseInt(col_input);\n                    let pos = [row, col];\n                    if(this.validPositionInput(pos)){\n                        callback(pos);\n                    }\n                    else{\n                        console.log(\"Try Again!\\n\");\n                        this.getMove(reader, callback);\n                    }\n                });\n            });\n        }\n        else{\n            console.log(`\\nAI plays at ${aiPos}\\n`);\n            callback(aiPos);\n        }\n    }\n\n    validMoves(){\n        return this.board.validPositions();\n    }\n\n}\n\nmodule.exports = Game;\n\n\n//# sourceURL=webpack:///./src/game/game.js?");

/***/ }),

/***/ "./src/game/inputError.js":
/*!********************************!*\
  !*** ./src/game/inputError.js ***!
  \********************************/
/***/ ((module) => {

eval("class InputError extends Error {\n    constructor(message) {\n        super(message); // (1)\n        this.name = \"Invalid Input\"; // (2)\n    }\n}\n\n//const moveError = function(msg) { return new MoveError(msg)};\n//let error = new MoveError(\"position is invalid\");\n\nmodule.exports = InputError;\n\n//# sourceURL=webpack:///./src/game/inputError.js?");

/***/ }),

/***/ "./src/game/moveError.js":
/*!*******************************!*\
  !*** ./src/game/moveError.js ***!
  \*******************************/
/***/ ((module) => {

eval("class MoveError extends Error {\n    constructor(message) {\n        super(message); // (1)\n        this.name = \"Invalid Move\"; // (2)\n    }\n}\n\n//const moveError = function(msg) { return new MoveError(msg)};\n//let error = new MoveError(\"position is invalid\");\n\nmodule.exports = MoveError;\n\n//# sourceURL=webpack:///./src/game/moveError.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const View = __webpack_require__(/*! ./ttt-view.js */ \"./src/ttt-view.js\");\n\nconst Game = __webpack_require__(/*! ./game/game.js */ \"./src/game/game.js\");\n\n  $(() => {\n\n    let $ttt = $('figure.ttt');\n    let view = new View($ttt);\n    view.startNewGame();\n  });\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/ttt-view.js":
/*!*************************!*\
  !*** ./src/ttt-view.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Game = __webpack_require__(/*! ./game/game */ \"./src/game/game.js\");\n\nclass View {\n  constructor($el, game = null) {\n    this.$el = $el;\n    this.game = game;\n    this.setupBoard();\n  }\n\n  bindEvents() {\n    //for select2 (drop-downs)\n    $('.selection-dropdown').select2({\n    width: 'resolve',\n    minimumResultsForSearch: Infinity\n    });\n    //enables toggling of AI menu\n    this.activateAIMenu();\n  }\n\n  startNewGame(){\n    this.resetBoard();\n    this.bindEvents();\n    this.showMenu();\n    $('.start-game-button').on('click',  (e)=> {\n        e.preventDefault();\n        this.hideMenu();\n        let $opponent = $('#opponent').val();\n        if($opponent === 'Human'){\n          this.playHuman();\n        } else{\n          let mark = $('#player-mark').val();\n          let aiLevel = parseInt($('#ai-level').val());\n          let aiMark = (mark === 'X') ? 'O' : 'X';\n          this.playAI(aiMark, aiLevel);\n        }\n    });\n  }\n\n  playAI(aiMark, aiLevel){\n    this.game = new Game(true, aiMark, aiLevel);\n    if(aiMark === 'X'){ //X plays first, if AI first, ai makes move\n      this.makeAIMove();\n    }\n    this.playerHover();\n    this.makeMove();\n  }\n\n  playHuman(){\n    this.game = new Game();\n    this.playerHover();\n    this.makeMove();\n  }\n  bindPostGameEventHandlers(){\n    $('.new-game-button').on('click', ()=>{\n      this.startNewGame();\n    });\n  }\n  //end game-- display winner at end of game (then resets game-- loads menu)\n  endGame(){\n      let winner = this.game.winner();\n      let win_msg = ''\n      if(winner === null){\n        win_msg = 'Tie Game';\n      }\n      else{\n        this.highlightWinningSquares(winner);\n        win_msg = winner + ' Wins!';\n      }\n      $('.winner-header').text(win_msg);\n      $('.winner-modal').removeClass('hidden');\n      this.bindPostGameEventHandlers();\n  }\n\n  highlightWinningSquares(winnerMark){\n    let winningPositions = this.game.winningPositions(winnerMark);\n    for(let i=0; i< winningPositions.length; i++){\n      let winPos = winningPositions[i];\n      let $winPos = $(`[data-pos= \"${winPos}\"]`);\n      $winPos.addClass('winner');\n      $winPos.addClass(winnerMark + \"-wins\");\n    }\n  }\n\n  //\n  checkForWin(){\n    if(this.game.isOver()){\n      this.endGame();\n      return true;\n    }\n    return false;\n  }\n\n  //reset board display (all squares blank)\n  resetBoard(){\n    $(\".pos\").off(\"hover\");\n    $( \".pos\" ).off( \"mouseenter mouseleave\");\n    $( \".unplayed\" ).off( \"mouseenter mouseleave\");\n    $('.start-game-button').off('click');\n    $('.pos').off('click');\n    $('ul').off('click');\n    $('.winner-header').text('');\n    $('.winner-modal').addClass('hidden');\n    const $pos = $('.pos');\n    $('.pos').removeClass('O-hovered');\n    $('.pos').removeClass('X-hovered');\n    $pos.addClass('unplayed');\n    $pos.removeClass('winner');\n    $pos.text('');\n    $pos.removeClass(\"X-played\");\n    $pos.removeClass(\"O-played\");\n    $pos.removeClass(\"X-wins\");\n    $pos.removeClass(\"O-wins\");\n  }\n  makeAIMove(){\n    //if(this.game.ai) called before calling this\n    //need to check if playing with AI first, then check if its ai's turn\n    if( this.game.ai && (this.game.currPlayerMark === this.game.aiMark) ){\n        let aiMove  = this.game.aiPlayer.getBestMove(this.game.board);\n        let aiMark = this.game.currPlayerMark;\n        let $aiSquare = $(`[data-pos= \"${aiMove}\"]`);\n        //checks if valid move (unplayed square)\n        if($aiSquare.hasClass(\"unplayed\")){\n          $aiSquare.removeClass('unplayed');\n          $('.pos').removeClass(aiMark + \"-hovered\");\n          $aiSquare.text(aiMark);\n          $aiSquare.addClass(aiMark + \"-played\");\n          this.game.makeMove(aiMove);\n          this.checkForWin();\n        }\n      }\n  }\n\n  //change square on grid after current player makes a move (display mark with associated color)\n  makeMove() {\n    $('ul.row').on('click', 'li.pos', (event)=>{\n      const $square = $(event.currentTarget);\n      if(!(this.game.isOver())){\n        const pos = $square.attr('data-pos');\n        const selected_position = [parseInt(pos[0]), parseInt(pos[2])];\n        let playerMark = this.game.currPlayerMark;\n        //checks if valid move (unplayed square)\n        if($square.hasClass(\"unplayed\")){\n          $square.removeClass('unplayed');\n          $('.pos').removeClass(playerMark + \"-hovered\");\n          $square.text(playerMark);\n          $square.addClass(playerMark + \"-played\");\n          this.game.makeMove(selected_position);\n          let win = this.checkForWin();\n          if(!(win) && this.game.ai){\n              this.makeAIMove();\n          }\n        }\n      }\n    });\n  }\n  //helper for player hover (determine if it is aiMove or not)\n  aiMove(game){\n    game = game || this.game;\n    return (game.ai && (game.aiMark === game.currPlayerMark));\n  }\n\n  //change each square while current player hovers over it (display mark [x or o] with associated color [red or blue]\n  playerHover(){\n    const game = this.game;\n    const aiMove = this.aiMove(game);\n    $('.unplayed').hover(\n      function(){\n        let playerMark = game.currPlayerMark;\n        if(!(game.isOver()) && !(aiMove)){\n          //let color = playerMark == 'O' ? 'blue':'red';\n          $(this).addClass(playerMark + \"-hovered\");\n        }\n      },\n      function(){\n        let playerMark = game.currPlayerMark;\n        if( !(game.isOver()) && !(aiMove)){\n          //.hovered\n          $(this).removeClass(playerMark + \"-hovered\");\n        }\n      }\n    );\n  }\n\n  //hide/show main menu\n  hideMenu(){\n    $('.game-menu').addClass('hidden');\n  }\n  showMenu(){\n    $('.game-menu').removeClass('hidden');\n  }\n\n  //only show choose player mark/ ai level if opponent is AI in menu\n  activateAIMenu(){\n    let $opponent_selection = $('#opponent');\n    $opponent_selection.change(function(){\n      if($(this).val() === 'AI'){\n        $('.play-AI-options').removeClass('hidden');\n      }\n      else{\n        $('.play-AI-options').addClass('hidden');\n      }\n    });\n  }\n  hideAIMenu(){\n    $('.play-AI-options').addClass('hidden');\n  }\n  showAIMenu(){\n    $('.play-AI-options').removeClass('hidden');\n  }\n\n  //setup blank board\n  setupBoard() {\n    const $grid = $('<div>').addClass('grid');\n    for(let rowIdx=0; rowIdx <3; rowIdx++){\n      const $row = $(\"<ul>\").addClass('row').attr('data-rowNum', rowIdx);\n      for(let colIdx =0; colIdx < 3; colIdx++){\n        let $pos = $(\"<li>\").addClass(\"pos unplayed\").attr('data-pos', [rowIdx, colIdx]);\n        $row.append($pos);\n      }\n      $grid.append($row);\n    }\n    this.$el.append($grid);\n  }\n}\n\nmodule.exports = View;\n\n\n//# sourceURL=webpack:///./src/ttt-view.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;