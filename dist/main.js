/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/game/aiPlayer.js":
/*!******************************!*\
  !*** ./src/game/aiPlayer.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Board = __webpack_require__(/*! ./board.js */ \"./src/game/board.js\");\nclass AIPlayer{\n    constructor(mark = 'X', maxDepth = -1){\n        this.mark = mark;\n        this.maxDepth = maxDepth;\n        this.nodesMap = new Map();\n    }\n    //returns opponents mark\n    opponentMark(){\n        return this.mark === 'X' ? 'O' : 'X';\n    }\n\n    //given an instance of board -- returns next best move (using max/min -- defaults to max possible depth unless maxDepth is set)\n    getBestMove(board, max = true, depth = 0){\n        if(depth == 0){\n            this.nodesMap.clear();\n        }\n        if(board.gameOver() || depth === this.maxDepth ) { //if end of game or max depth and...\n            if(board.winner() === this.mark) { //AI gets win\n                return 1000 - depth;\n            } else if (board.winner() === this.opponentMark()) { //opponent gets win\n                return -1000 + depth;\n            }//tie\n            return 0; //no change\n        }\n            //MAX/MIN\n            //Initialize best to the lowest possible value if max, highest if min (*uses 1000 for 'infinity')\n            let best = max === true ? -1000 : 1000;\n            //get current player mark (if maximizing --AI, else simulating human/ minimizing)\n            let mark = max === true ? this.mark : this.opponentMark();\n            //Loop through all empty cells on board (having the current player make a move on it and recursively calling getBestMove)\n            board.validPositions().forEach(pos => {\n                //Initialize a new board with a copy of current boards\n                const child = new Board();\n                child.grid = [];\n                board.grid.forEach( (row) => { child.grid.push([...row]) });\n                //Create a child node by inserting the current players' mark into the current empty cell\n                child.placeMark(pos, mark);\n                //Recursively call getBestMove with new board (after making a move), changing min/max (whose turn it is), and incrementing the depth\n                const nodeValue = this.getBestMove(child, (!max), depth + 1);\n                //Update best value (heuristic value) based on whose turn it is\n                best = (max === true) ? Math.max(best, nodeValue): Math.min(best, nodeValue);\n                //If it's the main function call, map each heuristic value with it's moves indices\n                if (depth == 0) {\n                    //separate pairs of position indices with a '-' if multiple moves have the same heuristic value\n                    const moves = this.nodesMap.has(nodeValue)\n                        ? this.nodesMap.get(nodeValue) + \"-\" + (pos)\n                        : pos;\n                    this.nodesMap.set(nodeValue, moves);\n                }\n            });\n            //If it's the main call, return the index of the best move\n            if (depth == 0) {\n                let bestPosition = this.nodesMap.get(best);\n                //if multiple indices have the same heuristic value (nodesMap value is a string of positions instead of an array), pick a random position\n                if (typeof bestPosition == \"string\") {\n                    let arr = this.nodesMap.get(best).split(\"-\"); //*positions stored as a string, seperated by '-'\n                    let numArr = [];\n                    for(let i =0; i < arr.length; i++){\n                        numArr.push([parseInt(arr[i][0]), parseInt(arr[i][2])]);\n                    }\n                    const rand = Math.floor(Math.random() * numArr.length);\n                    bestPosition = numArr[rand];\n                }\n                //return best position\n                return bestPosition;\n            }\n            //If not the main call (recursive call) return best scored move\n            return best;\n    }\n}\n\n\n\nmodule.exports = AIPlayer;\n\n\n//# sourceURL=webpack:///./src/game/aiPlayer.js?");

/***/ }),

/***/ "./src/game/board.js":
/*!***************************!*\
  !*** ./src/game/board.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const MoveError = __webpack_require__(/*! ./moveError */ \"./src/game/moveError.js\");\n\nclass Board{\n    constructor(){\n        this.grid = Board.makeGrid();\n    }\n    //make a grid (an array with 3 sub-arrays, where each subarray has 3 null elements)\n    static makeGrid(){\n        const grid = [];\n        for(let i = 0; i < 3; i++){\n            grid.push([]);\n            for(let j = 0; j < 3; j++){\n                grid[i].push(null);\n            }\n        }\n        return grid;\n    }\n    //check for win given a mark\n    won(mark){\n        let three_adjacent =[ //all possible configurations for a win\n        [this.grid[0][0], this.grid[1][1], this.grid[2][2]], //diagonals\n        [this.grid[0][2], this.grid[1][1], this.grid[2][0]],\n\n        [this.grid[0][0], this.grid[0][1], this.grid[0][2]], //horizontals\n        [this.grid[1][0], this.grid[1][1], this.grid[1][2]],\n        [this.grid[2][0], this.grid[2][1], this.grid[2][2]],\n\n        [this.grid[0][0], this.grid[1][0], this.grid[2][0]], //verticals\n        [this.grid[0][1], this.grid[1][1], this.grid[2][1]],\n        [this.grid[0][2], this.grid[1][2], this.grid[2][2]]\n        ]\n        for(let configs = 0; configs < three_adjacent.length; configs++){\n            let count = 0;\n            three_adjacent[configs].forEach(el=>{ //count # of same mark in positions needed for a win\n                if(el === mark){\n                    count+=1;\n                }\n            }); //if 3 in a row, return win\n            if(count === 3){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //returns array of winning positions (helpful for highlighting winning positions)\n    winningPositions(mark){\n        mark = mark || this.winner();\n        if (mark === null){\n            return [];\n        }\n        let three_adjacent =[\n        [[0,0], [1,1], [2,2]], //diagonals\n        [[0,2], [1,1], [2,0]],\n\n        [[0,0], [0,1], [0,2]], //horizontals\n        [[1,0], [1,1], [1,2]],\n        [[2,0], [2,1], [2,2]],\n\n        [[0,0], [1,0], [2,0]], //verticals\n        [[0,1], [1,1], [2,1]],\n        [[0,2], [1,2], [2,2]]\n        ]\n        let winningPositions = []\n        for(let group = 0; group < three_adjacent.length; group++){\n            winningPositions = [];\n            three_adjacent[group].forEach(pos=>{\n                if(this.getMark(pos) === mark){\n                    winningPositions.push(pos);\n                }\n            });\n            if(winningPositions.length === 3){\n                return winningPositions;\n            }\n        }\n        return [];\n    }\n\n    //check if game is over (there is a winner or the board is full)\n    gameOver(){\n        let validPositions = this.validPositions();\n        if(this.won('X') || this.won('O') || (validPositions.length === 0)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    //return winner (check if x won or o won, if tie return null)\n    winner(){\n        if(this.won('X')){\n            return 'X';\n        }\n        else if(this.won('O')){\n            return 'O';\n        }\n        else{\n            return null;\n        }\n    }\n\n    //checks for valid position (useful for console game-play)\n    isValid(pos){\n        if((pos.length !== 2)){\n            console.log(\"invalid length\");\n            return false;\n        }\n        if(typeof(pos[0]) !== 'number' || typeof(pos[1]) !== 'number'){\n            return false;\n        }\n        if(pos[0] < 0 || pos[0] > 2){\n            return false;\n        }\n        else if(pos[1] < 0 || pos[1] > 2){\n            return false;\n        }\n        else{\n            return true;\n        }\n    }\n\n    //returns mark at current position\n    getMark(pos){\n        if(this.isValid(pos)){\n            return this.grid[pos[0]][pos[1]];\n        }\n        else{\n            //console.log(\"Invalid position -- not valid entry/ not on the board!\");\n            throw new MoveError(`${pos} is not valid position on the board`);\n        }\n    }\n\n    //check if position is empty (null)\n    isEmpty(pos){\n        return (this.getMark(pos) === null);\n    }\n\n    //returns array of valid positions (empty positions)\n    validPositions(){\n        let positions = [];\n        for(let i =0; i < 3; i ++){\n            for(let j =0; j < 3; j ++){\n                if(this.isEmpty([i,j])){\n                    positions.push([i,j]);\n                }\n            }\n        }\n        return positions;\n    }\n    //places a mark at a given position (if it is empty -- otherwise throws error)\n    placeMark(pos, mark){\n        if(this.isEmpty(pos)){\n            this.grid[pos[0]][pos[1]] = mark;\n        }\n        else{\n            throw new MoveError(`${pos} is not an empty position on the board`);\n        }\n    }\n\n    //print game to console\n    print(){\n        console.log(\"    0  1  2\");\n        for(let row = 0; row < 3; row++){\n            let rowStr = \"\";\n            rowStr += row + \"  \";\n            for(let col = 0; col < 3; col++){\n                if(this.grid[row][col] === null){\n                    rowStr += \" _ \";\n                }\n                else{\n                    rowStr += ` ${this.grid[row][col]} `;\n                }\n            }\n            console.log(rowStr);\n        }\n    }\n}\nBoard.marks = ['X', 'O'];\nmodule.exports = Board;\n\n\n//# sourceURL=webpack:///./src/game/board.js?");

/***/ }),

/***/ "./src/game/game.js":
/*!**************************!*\
  !*** ./src/game/game.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Board = __webpack_require__(/*! ./board.js */ \"./src/game/board.js\");\nconst MoveError = __webpack_require__(/*! ./moveError */ \"./src/game/moveError.js\");\nconst InputError = __webpack_require__(/*! ./inputError */ \"./src/game/inputError.js\");\nconst AIPlayer = __webpack_require__(/*! ./aiPlayer.js */ \"./src/game/aiPlayer.js\");\n\nclass Game{\n    constructor(ai = false, aiMark ='X', aiLevel = -1){\n        this.board = new Board();\n        this.ai = ai;\n        if(ai === true){\n            this.aiMark = aiMark;\n            this.aiPlayer = new AIPlayer(aiMark, aiLevel);\n        }\n        this.currPlayerMark = Board.marks[0];\n    }\n    //check if gameOver\n    isOver(){\n        return this.board.gameOver();\n    }\n    //returns array of winningPositions\n    winningPositions(mark){\n        if (this.winner() !== null){\n            return this.board.winningPositions(mark);\n        }\n    }\n    //returns winner (from current instance of board)\n    winner(){\n        return this.board.winner();\n    }\n    //make a move on the board with current players mark and swap turns\n    makeMove(pos){\n        this.board.placeMark(pos, this.currPlayerMark);\n        this.swapTurn();\n    }\n    //helper to change currPlayer mark (X or O)\n    swapTurn(){\n        this.currPlayerMark = this.currPlayerMark === Board.marks[0] ?  Board.marks[1] : Board.marks[0];\n    }\n\n    //checks for valid console input\n    validInput(input){\n        try{\n            if(typeof(parseInt(input)) !== 'number' || isNaN(parseInt(input)) ){\n            throw new InputError(`${input} is not a valid input. Please enter a number (0 <= n <=2).\\n`);\n            }\n        } catch(e){\n            if(e instanceof InputError){\n                console.log(e.message);\n            }\n            else{\n                throw(e);\n            }\n        }\n    }\n\n    //run game for console play\n    run(reader, completionCallback){\n        this.getMove(reader, (pos) => {\n            try{\n                this.makeMove(pos);\n            } catch(e){\n                if(e instanceof MoveError){\n                    console.log(e.message);\n                }\n                else if(e instanceof InputError){\n                    console.log(e.message);\n                }\n                else{\n                    console.log(e.message);\n                    throw e;\n                }\n            }\n            if(this.isOver()){\n                this.board.print();\n                let winner = this.board.winner();\n                console.log(\"\\nGame Over!\");\n                if(winner === null){\n                    console.log('TIE -- NO ONE WINS!\\n');\n                }\n                else{\n                    console.log(`${winner} Wins!\\n`);\n                }\n                completionCallback();\n            }\n            else {\n                this.run(reader, completionCallback);\n            }\n        });\n    }\n    //check if input is valid as a position\n    validPositionInput(input){\n        if(!(Number.isNaN(input[0]) || Number.isNaN(input[1]))){\n            return true;\n        }\n    }\n\n    //gets a move through reader (console input)\n    getMove(reader, callback){\n        let aiMove = false;\n        let aiPos = [];\n        if(this.ai === true && this.aiMark === this.currPlayerMark){\n            aiMove = true;\n            aiPos = this.aiPlayer.getBestMove(this.board);\n        }\n        else{\n            this.board.print();\n        }\n        console.log(`\\n${this.currPlayerMark}'s Turn`);\n\n        if(aiMove === false){\n            console.log(\"\\nWhere would you like to move? \\t\");\n            reader.question(\"\\Please enter row number (0 <= n <= 2): \\t\", (row_input)=>{\n                let row = parseInt(row_input);\n                this.validInput(row_input);\n                reader.question(\"\\Please enter column number (0 <= n <= 2): \\t\", (col_input)=>{\n                    this.validInput(col_input);\n                    let col = parseInt(col_input);\n                    let pos = [row, col];\n                    if(this.validPositionInput(pos)){\n                        callback(pos);\n                    }\n                    else{\n                        console.log(\"Try Again!\\n\");\n                        this.getMove(reader, callback);\n                    }\n                });\n            });\n        }\n        else{\n            console.log(`\\nAI plays at ${aiPos}\\n`);\n            callback(aiPos);\n        }\n    }\n\n    //returns array of all valid positions on the board\n    validMoves(){\n        return this.board.validPositions();\n    }\n\n}\n\nmodule.exports = Game;\n\n\n//# sourceURL=webpack:///./src/game/game.js?");

/***/ }),

/***/ "./src/game/inputError.js":
/*!********************************!*\
  !*** ./src/game/inputError.js ***!
  \********************************/
/***/ ((module) => {

eval("class InputError extends Error {\n    constructor(message) {\n        super(message); // (1)\n        this.name = \"Invalid Input\"; // (2)\n    }\n}\n\n//const moveError = function(msg) { return new MoveError(msg)};\n//let error = new MoveError(\"position is invalid\");\n\nmodule.exports = InputError;\n\n//# sourceURL=webpack:///./src/game/inputError.js?");

/***/ }),

/***/ "./src/game/moveError.js":
/*!*******************************!*\
  !*** ./src/game/moveError.js ***!
  \*******************************/
/***/ ((module) => {

eval("class MoveError extends Error {\n    constructor(message) {\n        super(message); // (1)\n        this.name = \"Invalid Move\"; // (2)\n    }\n}\n\n//const moveError = function(msg) { return new MoveError(msg)};\n//let error = new MoveError(\"position is invalid\");\n\nmodule.exports = MoveError;\n\n//# sourceURL=webpack:///./src/game/moveError.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const View = __webpack_require__(/*! ./ttt-view.js */ \"./src/ttt-view.js\");\n\nconst Game = __webpack_require__(/*! ./game/game.js */ \"./src/game/game.js\");\n\n  $(() => {\n\n    let $ttt = $('figure.ttt');\n    //let game = new Game();\n    let view = new View($ttt,null);\n    view.startNewGame();\n  });\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/ttt-view.js":
/*!*************************!*\
  !*** ./src/ttt-view.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Game = __webpack_require__(/*! ./game/game */ \"./src/game/game.js\");\n\nclass View {\n  constructor($el, game = null) {\n    this.$el = $el;\n    this.game = game;\n    this.setupBoard();\n  }\n  //binds menu events\n  bindMenuEvents(){\n  //enables toggling of AI menu\n    this.activateAIMenuEvent();\n    //hover over square with mouse\n    this.replayGameEvent();\n    //start button in main menu\n    this.startButtonEvent();\n    this.select2Events();\n  }\n\n  //binds game play events\n  bindGameEvents(){\n    this.makeMoveEvent();\n    this.playerHoverEvent();\n  }\n\n  //binds all events (game play and menu)\n  bindEvents() {\n    //EVENTs for:\n    this.select2Events();\n    //enables toggling of AI menu\n    this.activateAIMenuEvent();\n    //hover over square with mouse\n    this.playerHoverEvent();\n    //start button in main menu\n    this.startButtonEvent();\n    //click to make move\n    this.makeMoveEvent();\n    //new game (after game over)\n    this.replayGameEvent();\n\n  }\n  select2Events(){\n    // select2 (drop-downs) event handlers (allows control over options selector width and removes the default search from drop down)\n    $('.selection-dropdown').select2({\n    width: 'resolve',\n    minimumResultsForSearch: Infinity\n    });\n  }\n  //event handler for new game (from main menu)\n  startButtonEvent(){\n    $('.start-game-button').on('click',  (e)=> {\n        //e.preventDefault();\n        this.hideMenu();\n        let $opponent = $('#opponent').val();\n        if($opponent === 'Human'){\n          this.playHuman();\n        } else{\n          let mark = $('#player-mark').val();\n          let aiLevel = parseInt($('#ai-level').val());\n          let aiMark = (mark === 'X') ? 'O' : 'X';\n          this.playAI(aiMark, aiLevel);\n        }\n    });\n  }\n  //event handler for new game (after game over)\n  replayGameEvent(){\n    $('.new-game-button').on('click', ()=>{\n      $('.winner-modal').fadeOut(500, ()=>{\n        $('.mark').fadeOut(500);\n        $('.pos').fadeTo(400, 0.4,()=>{\n          this.resetBoard();\n          $('.pos').fadeTo(100, 1, ()=>{\n          this.showMenu();\n          });\n        });\n      });\n    });\n  }\n\n  //change square on grid after current player makes a move (display mark with associated color)\n  makeMoveEvent() {\n    $('ul.row').on('click', 'li.pos', (event)=>{\n      const $square = $(event.currentTarget);\n      if(!(this.game.isOver())){\n        const pos = $square.attr('data-pos');\n        const selected_position = [parseInt(pos[0]), parseInt(pos[2])];\n        let playerMark = this.game.currPlayerMark;\n        //let $dataPosSq = $(`[data-pos= \"${selected_position}\"]`); //-- another way of getting currentTarget\n        //checks if valid move (unplayed square)\n        if($square.hasClass(\"unplayed\")){\n          $square.removeClass('unplayed');\n          $('.pos').removeClass(playerMark + \"-hovered\");\n          $square.addClass(playerMark + \"-played\");\n          this.addMark($square, playerMark);\n          this.game.makeMove(selected_position);\n          let win = this.checkForWin();\n          if(!(win) && this.game.ai){\n              this.makeAIMove();\n          }\n        }\n      }\n    });\n  }\n\n  //change each square while current player hovers over it (display mark [x or o] with associated color [red or blue]\n  playerHoverEvent(){\n    $('ul.row').on('mouseenter', 'li.unplayed', (event)=>{\n      const $square = $(event.currentTarget);\n      let playerMark = this.game.currPlayerMark;\n      if(!(this.game.isOver()) && !(this.aiMove(this.game))){\n          $square.addClass(playerMark + \"-hovered\");\n      }\n    });\n    $('ul.row').on('mouseleave', 'li.unplayed', (event)=>{\n      const $square = $(event.currentTarget);\n      let playerMark = this.game.currPlayerMark;\n      if( !(this.game.isOver()) && !(this.aiMove(this.game))){\n          $square.removeClass(playerMark + \"-hovered\");\n      }\n    });\n  }\n\n  //helper for new game against AI\n  playAI(aiMark, aiLevel){\n    this.game = new Game(true, aiMark, aiLevel);\n    if(aiMark === 'X'){ //X plays first, if AI first, ai makes move\n      this.makeAIMove();\n    }\n  }\n\n  //helper for new game against human\n  playHuman(){\n    this.game = new Game();\n  }\n\n  //only show choose player mark/ ai level if opponent is AI in menu\n  activateAIMenuEvent(){\n    let that = this;\n    let $opponent_selection = $('#opponent');\n    $opponent_selection.change(function(){\n      console.log('change');\n      if($(this).val() === 'AI'){\n        that.showAIMenu();\n      }\n      else{\n        that.hideAIMenu();\n      }\n    });\n  }\n\n  //binds menu events, resets board, displays menu, binds game play events\n  startNewGame(){\n    this.bindMenuEvents();\n    this.resetBoard();\n    this.showMenu();\n    this.bindGameEvents();\n  }\n\n  //end game-- display winner at end of game (then resets game-- loads menu)\n  endGame(){\n      let winner = this.game.winner();\n      let win_msg = ''\n      if(winner === null){ \n        win_msg = 'Tie Game';\n      }\n      else{ //if not a tie, display the 3 winning marks\n        this.highlightWinningSquares(winner);\n        win_msg = winner + ' Wins!';\n      }\n      $('.winner-header').text(win_msg);\n      $('.winner-modal').fadeIn(1000);\n  }\n\n  //highlights winning squares ()\n  highlightWinningSquares(winnerMark){\n    winnerMark = winnerMark || this.game.winner();\n    let winningPositions = this.game.winningPositions(winnerMark);\n    for(let i=0; i< winningPositions.length; i++){\n      let winPos = winningPositions[i];\n      let $winPos = $(`[data-pos= \"${winPos}\"]`);\n      $winPos.addClass(winnerMark + \"-wins\").fadeIn(1000);\n    }\n  }\n\n  //check if game is over, if it is, call endGame()\n  checkForWin(){\n    if(this.game.isOver()){\n      this.endGame();\n      return true;\n    }\n    return false;\n  }\n\n  //unbinds all set events\n  unbindEvents(){\n    const $eventSelectors = $(\".pos, .unplayed, .mark, li, button, .start-game-button, .new-game-button, ul, .row\");\n    $eventSelectors.off( \"mouseenter mouseleave click\");\n  }\n\n  //reset board display (all squares blank) -- removes classes for display, adds 'hidden class' to end of game display modal (winner-modal)\n  resetBoard(){\n    const $square = $(\".pos, .unplayed, .mark\");\n    const $pos = $('.pos');\n    $('.winner-header').text('');\n    $('.winner-modal').addClass('hidden');\n    $square.removeClass('O-hovered X-hovered X-played O-played X-wins O-wins winner reset-square-background');\n    $pos.addClass('unplayed');\n    $square.text('');\n  }\n\n  //helper to make AI move\n  makeAIMove(){\n    //if(this.game.ai) called before calling this\n    //**need to check if playing with AI first, then check if its ai's turn\n    if( this.game.ai && (this.game.currPlayerMark === this.game.aiMark) ){\n        let aiMove  = this.game.aiPlayer.getBestMove(this.game.board);\n        let aiMark = this.game.currPlayerMark;\n        let $aiSquare = $(`[data-pos= \"${aiMove}\"]`);\n        //checks if valid move (unplayed square)\n        if($aiSquare.hasClass(\"unplayed\")){\n          $aiSquare.removeClass('unplayed');\n          $('.pos').removeClass(aiMark + \"-hovered\");\n          $aiSquare.addClass(aiMark + \"-played\");\n          this.addMark($aiSquare, aiMark);\n          this.game.makeMove(aiMove);\n          this.checkForWin();\n        }\n      }\n  }\n\n  //add X or O mark as span inside of li (.pos class)\n  addMark($square, mark){\n    let markTxt = $(\"<span>\").addClass('mark').text(mark).fadeIn(500);\n    $square.append(markTxt);\n  }\n  //flash fadeinfadeout on element\n  flashFade(el){\n    el.fadeOut(1000,function(){\n      el.fadeIn(1000);\n    });\n  }\n\n  //helper for player hover (determine if it is aiMove or not)\n  aiMove(game){\n    game = game || this.game;\n    return (game.ai && (game.aiMark === game.currPlayerMark));\n  }\n\n  //hide/show main menu\n  hideMenu(){\n    $('.game-menu').fadeOut();\n  }\n  showMenu(){\n    console.log('showMenu');\n    $('.game-menu').fadeIn();\n  }\n\n  //hide/show AI options in Menu\n  hideAIMenu(){\n      $('.play-AI-options').addClass('hidden');\n  }\n  showAIMenu(){\n    $('.play-AI-options').removeClass('hidden');\n  }\n\n  //setup blank board\n  setupBoard() {\n    console.log('setupBoard');\n    const $grid = $('<div>').addClass('grid');\n    for(let rowIdx=0; rowIdx <3; rowIdx++){\n      const $row = $(\"<ul>\").addClass('row').attr('data-rowNum', rowIdx);\n      for(let colIdx =0; colIdx < 3; colIdx++){\n        let $pos = $(\"<li>\").addClass(\"pos unplayed\").attr('data-pos', [rowIdx, colIdx]);\n        $row.append($pos);\n      }\n      $grid.append($row);\n    }\n    this.$el.append($grid);\n  }\n}\n\nmodule.exports = View;\n\n\n//# sourceURL=webpack:///./src/ttt-view.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;